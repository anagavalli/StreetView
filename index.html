<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
  <title>Street View</title>

  <!-- Bootstrap -->
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/cs4620.css" rel="stylesheet">
  <link href="css/jquery-ui.min.css" rel="stylesheet">
  <link href="css/jquery-ui.theme.min.css" rel="stylesheet">
  <link href="css/jquery-ui.structure.min.css" rel="stylesheet">

  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>
<body onresize="resizeCanvas()">
<div class="container">
  <h1>WebGL Demo <span class="subtitle">Street View</span></h1>

  <div align="center">
    <!-- Canvas size is based on window size, values here are placeholder until render. -->
    <canvas id="webglCanvas" style="border: none; background-color: black;" width="100" height="100"></canvas>
  </div>
</div>

<!-- External libraries -->
<script src="js/jquery-3.1.1.min.js"></script>
<script src="js/exif.js"></script>
<script src="js/jquery-ui.min.js"></script>
<script src="js/gl-matrix.js"></script>
<script src="js/preloadjs.min.js"></script>
<script src="js/math.js"></script>

<!-- My libraries -->
<script src="js/webgl-util.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec3 vert_position;
    attribute vec2 vert_texCoord;

    varying vec2 geom_texCoord;

    void main() {
        gl_Position = vec4(vert_position, 1.0);
        geom_texCoord = vert_texCoord;
    }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
    precision highp float;

    const float PI = 3.14159265359;

    varying vec2 geom_texCoord;

    uniform vec3 cameraX;
    uniform vec3 cameraY;
    uniform vec3 cameraZ;
    uniform float cameraSHoriz;
    uniform float cameraSVert;

    uniform sampler2D photo;

    void main() {
        vec3 rayDir = normalize(
          -cameraZ
          - ((cameraSHoriz * geom_texCoord.x) * cameraX)
          - ((cameraSVert * geom_texCoord.y) * cameraY));

        // theta is atan(x/z)
        // rho is acos(y/hyp)

        float theta = atan(rayDir.x, rayDir.z);
        if (theta < 0.0) { theta = theta + 2.0 * PI; }
        float rho = acos(rayDir.y / length(rayDir));

        gl_FragColor = texture2D(photo, vec2(theta / (2.0 * PI), rho / PI));
    }
</script>

<script id="chevronVertexShader" type="x-shader/x-vertex">
    attribute vec3 vert_position;
    attribute vec2 vert_texCoord;

    uniform mat4 toWorld;

    varying vec2 geom_texCoord;

    void main() {
        gl_Position = toWorld * vec4(vert_position, 1.0);
        geom_texCoord = vert_texCoord;
    }
</script>

<script id="chevronFragmentShader" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 geom_texCoord;

    uniform sampler2D chevron;

    void main() {
        vec4 texColor = texture2D(chevron, geom_texCoord);
        if (texColor.a < 0.1) { discard; }
        gl_FragColor = vec4(texColor.xyz, 0.75);
    }
</script>

<script>
  "use strict"

  // Set initial canvas size based on window size
  resizeCanvas();
  // Create a LoadQueue object.
  const imageQueue = new createjs.LoadQueue();
  const startingTarget = vec3.fromValues(0, 0, -1);
  const startingUp = vec3.fromValues(0, 1, 0);
  const startingFov = 50.0;

  function initWebGL() {
    // Register the callback function to run when all images have loaded.
    imageQueue.on("complete", function() {
      getImageMetadata(imageQueue, runWebGL);
    }, this);
    // List the files you want to load, with their corresponding ID.
    imageQueue.loadManifest([
      {
        id: "arts-quad",
        src: "img/arts-quad.jpeg"
      },
      {
        id: "big-red-barn",
        src: "img/big-red-barn.jpeg"
      },
      {
        id: "chevron",
        src: "img/chevron.png"
      },
      {
        id: "east-avenue",
        src: "img/east-avenue.jpeg"
      },
      {
        id: "gates-hall",
        src: "img/gates-hall.jpeg"
      },
      {
        id: "hoy-field",
        src: "img/hoy-field.jpeg"
      },
      {
        id: "mcgraw-tower",
        src: "img/mcgraw-tower.jpeg"
      },
      {
        id: "mudd-hall",
        src: "img/mudd-hall.jpeg"
      },
      {
        id: "statler-hall",
        src: "img/statler-hall.jpeg"
      },
      {
        id: "teagle-hall",
        src: "img/teagle-hall.jpeg"
      },
      {
        id: "upson-hall",
        src: "img/upson-hall.jpeg"
      },
      {
        id: "uris-hall",
        src: "img/uris-hall.jpeg"
      }
    ]);
  }

  function runWebGL(metadata) {
    const canvasQuery = $("#webglCanvas");
    const canvas = canvasQuery[0];
    const gl = initializeWebGL(canvas);
    const program = createGlslProgram(gl, "vertexShader", "fragmentShader");
    const chevronProgram = createGlslProgram(gl, "chevronVertexShader", "chevronFragmentShader");

    // Variables for camera movement
    let horizRot = 0;
    let vertRot = 0;
    let lastMousePos = {};
    let fov = startingFov;
    let neighbors = [];

    // Create a fullscreen quad to display our viewport
    const viewportData = {
      vertices: [
        -1.0, -1.0, 0.0,  // Lower left, vert_position
        -1.0,  -1.0,        // vert_texCoord
        1.0, -1.0, 0.0,  // Lower right
        1.0,  -1.0,
        1.0,  1.0, 0.0,  // Top right
        1.0,  1.0,
        -1.0,  1.0, 0.0,  // Top left
        -1.0,  1.0
      ],
      indices: [
        0, 1, 2,
        0, 2, 3
      ]
    }
    const viewportShape = createShape(gl, viewportData);

    const chevronData = {
      vertices: [
        -1.0, -1.0, 0.0,  // Lower left, vert_position
        0.0,  1.0,        // vert_texCoord
        1.0, -1.0, 0.0,  // Lower right
        1.0,  1.0,
        1.0,  1.0, 0.0,  // Top right
        1.0,  0.0,
        -1.0,  1.0, 0.0,  // Top left
        0.0,  0.0
      ],
      indices: [
        0, 1, 2,
        0, 2, 3
      ]
    }
    const chevronShape = createShape(gl, chevronData);

    const numImages = metadata.length - 1;
    const gFrom = [], gTo = [], gWeight = [], gBearing = [];

    for (let i = 0; i < metadata.length; i++) {
      const data = metadata[i];
      if (data.poseHeadingDegrees === undefined) { continue; }

      for (let j = i + 1; j < metadata.length; j++) {
        const otherData = metadata[j];
        if (otherData.poseHeadingDegrees === undefined) { continue; }

        gFrom.push(data.id);
        gTo.push(otherData.id);

        const startPos = {
          y: degToDecimal(data.latitude),
          x: degToDecimal(data.longitude)
        }
        const endPos = {
          y: degToDecimal(otherData.latitude),
          x: degToDecimal(otherData.longitude)
        }

        gWeight.push(distance(startPos, endPos));
        gBearing.push(findBearing(startPos, endPos));
      }
    }

    const mst = kruskal(numImages, math.combinations(numImages, 2), gFrom, gTo, gWeight, gBearing);
    let sceneImage;

    function setNewScene(newImage) {
      canvasQuery.off('mousedown');
      canvasQuery.off('mouseup');
      canvasQuery.off('wheel');

      horizRot = 0;
      vertRot = 0;
      lastMousePos = {};
      sceneImage = newImage;

      // Camera movement callbacks
      canvasQuery.on('mousedown', function (event) {
        const clientRect = canvas.getBoundingClientRect();
        lastMousePos = {
          x: event.clientX - clientRect.left,
          y: event.clientY - clientRect.top
        };

        canvasQuery.on('mousemove', function(event) {
          const clientRect = canvas.getBoundingClientRect();
          const curMousePos = {
            x: event.clientX - clientRect.left,
            y: event.clientY - clientRect.top
          };

          // Negate so that camera moves in opposite direction of mouse move
          const deltaHoriz = -1 * pixelsToRads(curMousePos.x - lastMousePos.x);
          const deltaVert = -1 * pixelsToRads(curMousePos.y - lastMousePos.y);

          horizRot = mod(horizRot + deltaHoriz, 2 * Math.PI);
          vertRot = clamp(vertRot + deltaVert, Math.PI / -2, Math.PI / 2);

          lastMousePos = curMousePos;
        });
      });
      canvasQuery.on('mouseup', function (event) {
        canvasQuery.off('mousemove');
      });
      canvasQuery.on('wheel', function(event){
        event.preventDefault();
        if(event.originalEvent.deltaY !== 0){
          fov += event.originalEvent.deltaY / 30;
          fov = clamp(fov, 10.0, 80.0);
        }
      });

      neighbors = [];
      mst.forEach(edge => {
        if (edge.v1 === sceneImage) {
          neighbors.push({
            scene: edge.v2,
            direction: edge.bearing
          })
        }
        else if (edge.v2 === sceneImage) {
          neighbors.push({
            scene: edge.v1,
            direction: 360 - edge.bearing
          })
        }
      });
    }

    setNewScene(mst[0].v1);

    function updateWebGL(timestamp) {
      // Adjust WebGL canvas if canvas element has been resized
      resizeCanvasToDisplaySize(gl.canvas);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      const curMetadata = getCurrentMetadata(metadata, sceneImage);

      const clientRect = canvas.getBoundingClientRect();
      const aspectRatio = clientRect.width / clientRect.height;
      const fovHoriz = fov;
      const fovVert = fov / aspectRatio;
      const camera = calculateCamera(horizRot, vertRot, fovHoriz, fovVert);

      const lookAt = camera.lookAt;
      const x = vec3.fromValues(lookAt[0], lookAt[4], lookAt[8]);
      const y = vec3.fromValues(lookAt[1], lookAt[5], lookAt[9]);
      const z = vec3.fromValues(lookAt[2], lookAt[6], lookAt[10]);

      gl.useProgram(program);

      gl.uniform3fv(gl.getUniformLocation(program, "cameraX"), x);
      gl.uniform3fv(gl.getUniformLocation(program, "cameraY"), y);
      gl.uniform3fv(gl.getUniformLocation(program, "cameraZ"), z);
      gl.uniform1f(gl.getUniformLocation(program, "cameraSHoriz"), camera.sHoriz);
      gl.uniform1f(gl.getUniformLocation(program, "cameraSVert"), camera.sVert)

      const sceneTexture = createTexture(gl, imageQueue.getResult(sceneImage, false), true);

      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, sceneTexture);
      gl.uniform1i(gl.getUniformLocation(program, "photo"), 1);

      gl.useProgram(null);

      drawShape(gl, program, viewportShape);

      canvasQuery.off('click');
      neighbors.forEach(neighbor => {
        // Chevron (for scene movement)
        // Model matrix
        const chevronRotation = (neighbor.direction - curMetadata.poseHeadingDegrees) * Math.PI / 180;
        const scale = mat4.fromScaling(mat4.create(), vec3.fromValues(0.07, 0.07, 0.07));
        const translation = mat4.fromTranslation(mat4.create(), vec3.fromValues(0, 0, -2));
        const rotation = mat4.fromRotation(mat4.create(), chevronRotation, y_axis);

        const model = mat4.multiply(mat4.create(), translation, scale);
        mat4.multiply(model, rotation, model);

        // View matrix
        const view = mat4.clone(camera.lookAt);

        // Projection matrix
        const projection = mat4.create();
        mat4.perspective(projection, startingFov, aspectRatio, 1, 1000);

        const toWorld = mat4.create();
        mat4.multiply(toWorld, view, model);
        mat4.multiply(toWorld, projection, toWorld);

        canvasQuery.on('click', function(event) {
          const clientRect = canvas.getBoundingClientRect();
          const curMousePos = {
            x: event.clientX - clientRect.left,
            y: event.clientY - clientRect.top
          };

          const clipMin = vec4.transformMat4(vec4.create(), vec4.fromValues(-1, -1, 0, 1), toWorld);
          vec4.scale(clipMin, clipMin, 1 / clipMin[3]);
          const clipMax = vec4.transformMat4(vec4.create(), vec4.fromValues(1, 1, 0, 1), toWorld);
          vec4.scale(clipMax, clipMax, 1 / clipMax[3]);

          const min = {
            x: (clipMax[0] + 1) / 2 * clientRect.width,
            y: clientRect.height - (clipMin[1] + 1) / 2 * clientRect.height
          }

          const max = {
            x: (clipMin[0] + 1) / 2 * clientRect.width,
            y: clientRect.height - (clipMax[1] + 1) / 2 * clientRect.height
          }

          if (boundsContain(curMousePos, min, max)) {
            setNewScene(neighbor.scene);
          }
        });

        gl.useProgram(chevronProgram);
        gl.uniformMatrix4fv(gl.getUniformLocation(chevronProgram, "toWorld"), false, toWorld);

        const chevronTexture = createTexture(gl, imageQueue.getResult("chevron", false), false);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, chevronTexture);
        gl.uniform1i(gl.getUniformLocation(chevronProgram, "chevron"), 0);

        gl.useProgram(null);

        drawShape(gl, chevronProgram, chevronShape);
      });

      window.requestAnimationFrame(updateWebGL);
    }

    window.requestAnimationFrame(updateWebGL);
  }

  // Calculates the orthonormal basis for the camera view given a horizRot and vertRot from
  // starting position, as well as per-pixel "s" value for perspective calculation, given fov.
  // Starting camera position is at origin looking along the negative z axis.
  function calculateCamera(horizRot, vertRot, fovHoriz, fovVert) {
    const target = vec3.clone(startingTarget);
    vec3.rotateX(target, target, origin, vertRot);
    vec3.normalize(target, target);
    vec3.rotateY(target, target, origin, horizRot);
    vec3.normalize(target, target);

    const up = vec3.clone(startingUp);
    vec3.rotateX(up, up, origin, vertRot);
    vec3.normalize(up, up);
    vec3.rotateY(up, up, origin, horizRot);
    vec3.normalize(up, up);

    const lookAt = mat4.create();
    mat4.lookAt(lookAt, origin, target, up);

    const sHoriz = Math.tan((fovHoriz / 2.0) * (Math.PI / 180.0));
    const sVert = Math.tan((fovVert / 2.0) * (Math.PI / 180.0));

    return {
      sHoriz: sHoriz,
      sVert: sVert,
      lookAt: lookAt
    };
  }

  // Converts from pixels of mouse movement to radians of rotation.
  // Arbitrarily picked as 10 pixels = 1 degree for a good feel.
  function pixelsToRads(pixels) {
    return pixels * Math.PI / 1800;
  }

  function resizeCanvas() {
    const canvas = document.getElementById("webglCanvas");
    canvas.width = window.innerWidth / 1.5;
    canvas.height = window.innerHeight / 1.5;
  }

  function resizeCanvasToDisplaySize(canvas) {
    // Lookup the size the browser is displaying the canvas in CSS pixels.
    const displayWidth  = canvas.clientWidth;
    const displayHeight = canvas.clientHeight;

    // Check if the canvas is not the same size.
    const needResize = canvas.width  !== displayWidth ||
      canvas.height !== displayHeight;

    if (needResize) {
      // Make the canvas the same size
      canvas.width  = displayWidth;
      canvas.height = displayHeight;
    }

    return needResize;
  }

  function getCurrentMetadata(metadata, curSceneId) {
    let curMetadata;

    metadata.forEach(data => {
      if (data.id === curSceneId) {
        curMetadata = data;
      }
    });

    return curMetadata;
  }

  initWebGL();
</script>

</body>
</html>